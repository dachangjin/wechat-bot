#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = __importDefault(require("tstest"));
const string_matcher_1 = require("./string-matcher");
tstest_1.default('stringMatcher() smoke testing', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const matcher = string_matcher_1.stringMatcher();
    t.equal(typeof matcher, 'function', 'should return a match function');
}));
tstest_1.default('stringMatcher()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const TEXT_OK = 'hello';
    const TEXT_NOT_OK = 'world';
    const falseMatcher = string_matcher_1.stringMatcher();
    t.false(yield falseMatcher(TEXT_OK), 'should not match any string: TEXT_OK');
    t.false(yield falseMatcher(TEXT_NOT_OK), 'should not match any string: TEXT_NOT_OK');
    const textMatcher = string_matcher_1.stringMatcher(TEXT_OK);
    t.true(yield textMatcher(TEXT_OK), 'should match expected TEXT');
    t.false(yield textMatcher(TEXT_NOT_OK), 'should not match unexpected string');
    const textListMatcher = string_matcher_1.stringMatcher([TEXT_OK]);
    t.true(yield textListMatcher(TEXT_OK), 'should match expected TEXT by list');
    t.false(yield textListMatcher(TEXT_NOT_OK), 'should not match unexpected string by list');
    const regexpMatcher = string_matcher_1.stringMatcher(new RegExp(TEXT_OK));
    t.false(yield regexpMatcher(TEXT_NOT_OK), 'should not match unexpected string by regexp');
    t.true(yield regexpMatcher(TEXT_OK), 'should match expected from by regexp');
    const regexpListMatcher = string_matcher_1.stringMatcher([new RegExp(TEXT_OK)]);
    t.false(yield regexpListMatcher(TEXT_NOT_OK), 'should not match unexpected string by regexp list');
    t.true(yield regexpListMatcher(TEXT_OK), 'should match expected from by regexp list');
    const stringFilter = (text) => text === TEXT_OK;
    const functionMatcher = string_matcher_1.stringMatcher(stringFilter);
    t.false(yield functionMatcher(TEXT_NOT_OK), 'should not match unexpected string by function');
    t.true(yield functionMatcher(TEXT_OK), 'should match expected from by function');
    const functionListMatcher = string_matcher_1.stringMatcher([stringFilter]);
    t.false(yield functionListMatcher(TEXT_NOT_OK), 'should not match unexpected string by function list');
    t.true(yield functionListMatcher(TEXT_OK), 'should match expected from by function list');
}));
//# sourceMappingURL=string-matcher.spec.js.map