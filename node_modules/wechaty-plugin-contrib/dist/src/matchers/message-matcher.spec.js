#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = __importDefault(require("tstest"));
const message_matcher_1 = require("./message-matcher");
tstest_1.default('messageMatcher() smoke testing', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const matcher = message_matcher_1.messageMatcher(/test/i);
    t.equal(typeof matcher, 'function', 'should return a match function');
}));
tstest_1.default('messageMatcher() with string option', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const TEXT_OK = 'hello';
    const TEXT_NOT_OK = 'world';
    const textOk = () => TEXT_OK;
    const roomOk = () => ({ id: TEXT_OK, topic: () => TEXT_OK });
    const fromOk = () => ({ id: TEXT_OK, name: () => TEXT_OK });
    const textNotOk = () => TEXT_NOT_OK;
    const roomNotOk = () => ({ id: TEXT_NOT_OK, topic: () => TEXT_NOT_OK });
    const fromNotOk = () => ({ id: TEXT_NOT_OK, name: () => TEXT_NOT_OK });
    const messageFromOk = {
        from: fromOk,
        id: TEXT_NOT_OK,
        mentionText: textNotOk,
        room: roomNotOk,
        text: textNotOk,
    };
    const messageTextOk = {
        from: fromNotOk,
        id: TEXT_NOT_OK,
        mentionText: textOk,
        room: roomNotOk,
        text: textOk,
    };
    const messageTopicOk = {
        from: fromNotOk,
        id: TEXT_NOT_OK,
        mentionText: textNotOk,
        room: roomOk,
        text: textNotOk,
    };
    const messageIdOk = {
        from: fromNotOk,
        id: TEXT_OK,
        room: roomOk,
        text: textNotOk,
    };
    const messageNotOk = {
        from: fromNotOk,
        id: TEXT_NOT_OK,
        mentionText: textNotOk,
        room: roomNotOk,
        text: textNotOk,
    };
    const falseMatcher = message_matcher_1.messageMatcher();
    t.false(yield falseMatcher(messageFromOk), 'should not match any message: from');
    t.false(yield falseMatcher(messageTopicOk), 'should not match any message: topic');
    t.false(yield falseMatcher(messageIdOk), 'should not match any message: text');
    const idMatcher = message_matcher_1.messageMatcher(TEXT_OK);
    t.false(yield idMatcher(messageNotOk), 'should not match unexpected message by id');
    t.true(yield idMatcher(messageFromOk), 'should match expected from by id');
    t.true(yield idMatcher(messageTopicOk), 'should match expected topic by id');
    t.true(yield idMatcher(messageIdOk), 'should match expected text by id');
    const idListMatcher = message_matcher_1.messageMatcher([TEXT_OK]);
    t.false(yield idListMatcher(messageNotOk), 'should not match unexpected message by id list');
    t.true(yield idListMatcher(messageFromOk), 'should match expected from by id list');
    t.true(yield idListMatcher(messageTopicOk), 'should match expected topic by id list');
    t.true(yield idListMatcher(messageIdOk), 'should match expected text by id list');
    const regexpMatcher = message_matcher_1.messageMatcher(new RegExp(TEXT_OK));
    t.false(yield regexpMatcher(messageNotOk), 'should not match unexpected message by regexp');
    t.true(yield regexpMatcher(messageFromOk), 'should match expected from by regexp');
    t.true(yield regexpMatcher(messageTopicOk), 'should match expected topic by regexp');
    t.true(yield regexpMatcher(messageTextOk), 'should match expected text by regexp');
    const regexpListMatcher = message_matcher_1.messageMatcher([new RegExp(TEXT_OK)]);
    t.false(yield regexpListMatcher(messageNotOk), 'should not match unexpected message by regexp');
    t.true(yield regexpListMatcher(messageFromOk), 'should match expected from by regexp');
    t.true(yield regexpListMatcher(messageTopicOk), 'should match expected topic by regexp');
    t.true(yield regexpListMatcher(messageTextOk), 'should match expected text by regexp');
    const messageFilter = (message) => {
        var _a, _b;
        return [
            message.text(),
            (_a = message.room()) === null || _a === void 0 ? void 0 : _a.topic(),
            (_b = message.from()) === null || _b === void 0 ? void 0 : _b.name(),
        ].includes(TEXT_OK);
    };
    const functionMatcher = message_matcher_1.messageMatcher(messageFilter);
    t.false(yield functionMatcher(messageNotOk), 'should not match unexpected message by function');
    t.true(yield functionMatcher(messageFromOk), 'should match expected from by function');
    t.true(yield functionMatcher(messageTopicOk), 'should match expected topic by function');
    t.true(yield functionMatcher(messageTextOk), 'should match expected text by function');
    const functionListMatcher = message_matcher_1.messageMatcher([messageFilter]);
    t.false(yield functionListMatcher(messageNotOk), 'should not match unexpected message by function list');
    t.true(yield functionListMatcher(messageFromOk), 'should match expected from by function list');
    t.true(yield functionListMatcher(messageTopicOk), 'should match expected topic by function list');
    t.true(yield functionListMatcher(messageTextOk), 'should match expected text by function list');
}));
//# sourceMappingURL=message-matcher.spec.js.map