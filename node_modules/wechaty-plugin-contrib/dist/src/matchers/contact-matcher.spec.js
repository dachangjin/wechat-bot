#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = __importDefault(require("tstest"));
const contact_matcher_1 = require("./contact-matcher");
tstest_1.default('contactMatcher() smoke testing', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const matcher = contact_matcher_1.contactMatcher(/test/i);
    t.equal(typeof matcher, 'function', 'should return a match function');
}));
tstest_1.default('contactMatcher() with string option', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const TEXT_OK = 'hello';
    const TEXT_NOT_OK = 'world';
    const nameOk = () => TEXT_OK;
    const nameNotOk = () => TEXT_NOT_OK;
    const contactIdOk = {
        id: TEXT_OK,
        name: nameNotOk,
    };
    const contactNameOk = {
        id: TEXT_NOT_OK,
        name: nameOk,
    };
    const contactNotOk = {
        id: TEXT_NOT_OK,
        name: nameNotOk,
    };
    const falseMatcher = contact_matcher_1.contactMatcher();
    t.false(yield falseMatcher(contactIdOk), 'should not match any contact without options');
    t.false(yield falseMatcher(contactNameOk), 'should not match any contact without options');
    const idMatcher = contact_matcher_1.contactMatcher(TEXT_OK);
    t.false(yield idMatcher(contactNotOk), 'should not match unexpected contact by id');
    t.true(yield idMatcher(contactIdOk), 'should match expected contact by id');
    t.false(yield idMatcher(contactNameOk), 'should not match contact by name');
    const idListMatcher = contact_matcher_1.contactMatcher([TEXT_OK]);
    t.false(yield idListMatcher(contactNotOk), 'should not match unexpected contact by id list');
    t.true(yield idListMatcher(contactIdOk), 'should match expected contact by id list');
    t.false(yield idListMatcher(contactNameOk), 'should not match contact by name list');
    const regexpMatcher = contact_matcher_1.contactMatcher(new RegExp(TEXT_OK));
    t.false(yield regexpMatcher(contactNotOk), 'should not match unexpected contact by regexp');
    t.false(yield regexpMatcher(contactIdOk), 'should match contact id by regexp');
    t.true(yield regexpMatcher(contactNameOk), 'should match expected contact name by regexp');
    const regexpListMatcher = contact_matcher_1.contactMatcher([new RegExp(TEXT_OK)]);
    t.false(yield regexpListMatcher(contactNotOk), 'should not match unexpected contact by regexp list');
    t.false(yield regexpListMatcher(contactIdOk), 'should not match contact id by regexp list');
    t.true(yield regexpListMatcher(contactNameOk), 'should match expected contact name by regexp list');
    const roomFilter = (room) => [
        room.id,
        room.name(),
    ].includes(TEXT_OK);
    const functionMatcher = contact_matcher_1.contactMatcher(roomFilter);
    t.false(yield functionMatcher(contactNotOk), 'should not match unexpected contact by function');
    t.true(yield functionMatcher(contactNameOk), 'should match expected name by function');
    t.true(yield functionMatcher(contactIdOk), 'should match expected id by function');
    const functionListMatcher = contact_matcher_1.contactMatcher([roomFilter]);
    t.false(yield functionListMatcher(contactNotOk), 'should not match unexpected contact by function list');
    t.true(yield functionListMatcher(contactNameOk), 'should match expected name by function list');
    t.true(yield functionListMatcher(contactIdOk), 'should match expected text by function list');
}));
//# sourceMappingURL=contact-matcher.spec.js.map