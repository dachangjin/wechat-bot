"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubRequestCancelError = exports.Status = exports.Request = void 0;
const padlocal_pb_1 = require("./proto/padlocal_pb");
const ActionMessageUtils_1 = require("./utils/ActionMessageUtils");
const PromiseUtils_1 = require("./utils/PromiseUtils");
const WeChatShortLinkProxy_1 = require("./link/WeChatShortLinkProxy");
const verror_1 = __importDefault(require("verror"));
const Utils_1 = require("./utils/Utils");
const SocketStreamHandler_1 = require("./link/SocketStreamHandler");
const LongLinkStreamHandler_1 = require("./link/LongLinkStreamHandler");
const PushStreamHandler_1 = require("./link/PushStreamHandler");
const GrpcClient_1 = require("./GrpcClient");
const PadLocalClientPlugin_1 = require("./PadLocalClientPlugin");
const FileUploadStreamHandler_1 = require("./link/FileUploadStreamHandler");
const ByteUtils_1 = require("./utils/ByteUtils");
const WeChatHttpProxy_1 = require("./link/WeChatHttpProxy");
const Log_1 = __importDefault(require("./utils/Log"));
const LOGPRE = "[Request]";
class Request extends PadLocalClientPlugin_1.PadLocalClientPlugin {
    constructor(client, options) {
        super(client);
        this._seqId = 0;
        this._pendingCallbacks = new Map();
        this._status = Status.OK;
        const meta = client.grpcClient.newRequestMeta(options);
        this.traceId = GrpcClient_1.GrpcClient.getTraceId(meta);
        this._requestTimeout = GrpcClient_1.GrpcClient.getTimeout(options);
        this._grpcStream = client.grpcClient.stub.action(meta, client.grpcClient.newRequestOptions(options));
        this._grpcStream.on("data", (serverMessage) => {
            this._onServerMessage(serverMessage).then();
        });
        this._grpcStream.on("end", () => {
            if (this._status !== Status.OK) {
                return;
            }
            this._failAllPendingRequest(Status.SERVER_COMPLETE, new Error("Server complete"));
            this._status = Status.SERVER_COMPLETE;
        });
        this._grpcStream.on("error", (error) => {
            if (this._status !== Status.OK) {
                return;
            }
            this._failAllPendingRequest(Status.SERVER_ERROR, error);
            this._status = Status.SERVER_ERROR;
        });
    }
    request(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const subResponse = (yield this.subRequest(request, false));
            return subResponse.payload;
        });
    }
    /**
     * @param request: request payload
     * @param sendOnly: if true, do not wait for server's ask, return null immediately
     * @return response
     */
    subRequest(request, sendOnly) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._sendMessage(request, sendOnly);
        });
    }
    subReply(ack, replay) {
        this._sendMessage(replay, true, ack).then();
    }
    /**
     * reply to ack, and send request need peer ack too
     * @param ack
     * @param request
     */
    subReplyAndRequest(ack, request) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this._sendMessage(request, false, ack));
        });
    }
    _sendMessage(request, sendOnly, ack) {
        return __awaiter(this, void 0, void 0, function* () {
            if (sendOnly) {
                this.__sendMessage(request, undefined, ack);
            }
            else {
                const newSeqId = ++this._seqId;
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        this._failPendingRequest(newSeqId, new GrpcClient_1.IOError(`[tid:${this.traceId}] subRequest timeout`));
                    }, this._requestTimeout);
                    this._pendingCallbacks.set(newSeqId, new PromiseUtils_1.PromiseCallback(resolve, reject, timeoutId));
                    this.__sendMessage(request, newSeqId, ack);
                });
            }
        });
    }
    /**
     * @param payload: message payload
     * @param seq: payload action and require ack reply
     * @param ack: reply action and reply #seq payload with ack
     *
     * Example:
     *  ┌───────┬───────┬───────────────────────────────────────────────┐
     *  │  seq  │  ack  │                  description                  │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │ null  │ null  │send only action, no ack required              │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │ null  │notnull│reply action, reply to payload that seq == ack │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │notnull│ null  │payload action, need ack                       │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │notnull│notnull│reply action, and also need peer to reply      │
     *  └───────┴───────┴───────────────────────────────────────────────┘
     */
    __sendMessage(payload, seq, ack) {
        if (this._status !== Status.OK && this._status !== Status.SERVER_COMPLETE) {
            throw new SubRequestCancelError(this.traceId, this._status, undefined, "can not send message while stream status is illegal");
        }
        const actionMessageHeader = new padlocal_pb_1.ActionMessageHeader();
        if (seq !== undefined) {
            actionMessageHeader.setSeq(seq);
        }
        if (ack !== undefined) {
            actionMessageHeader.setAck(ack);
        }
        const actionMessage = new padlocal_pb_1.ActionMessage();
        actionMessage.setHeader(actionMessageHeader);
        ActionMessageUtils_1.setPayload(actionMessage, payload);
        Log_1.default.silly(LOGPRE, `[tid:${this.traceId}] send event to server, seq:${seq}, ack:${ack}, type: ${actionMessage.getPayloadCase()}, payload: ${Utils_1.stringifyPB(payload, ByteUtils_1.MAX_LOG_BYTES_LEN)}`);
        this._grpcStream.write(actionMessage);
    }
    _onServerMessage(serverMessage) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const seq = serverMessage.getHeader().getSeq();
            const ack = serverMessage.getHeader().getAck();
            const payload = ActionMessageUtils_1.getPayload(serverMessage);
            Log_1.default.silly(LOGPRE, `[tid:${this.traceId}] receive event from server, seq:${seq} ack:${ack}, type:${serverMessage.getPayloadCase()}, payload:${Utils_1.stringifyPB(payload, ByteUtils_1.MAX_LOG_BYTES_LEN)}`);
            // server response, execute on stream executor thread directly
            if (ack) {
                this._completePendingRequest(ack, ActionMessageUtils_1.getPayload(serverMessage), seq);
            }
            else {
                // forward payload to wechat server, and then forward response to our server
                if (serverMessage.getPayloadCase() === padlocal_pb_1.ActionMessage.PayloadCase.WECHATREQUEST) {
                    try {
                        yield this._handleNormalRequest(serverMessage.getWechatrequest(), seq);
                    }
                    catch (e) {
                        this.error(new GrpcClient_1.IOError(e, `[tid:${this.traceId}] Exception while handling wechat request`));
                    }
                }
                else if (serverMessage.getPayloadCase() === padlocal_pb_1.ActionMessage.PayloadCase.WECHATSTREAMREQUEST) {
                    try {
                        yield this._handleStreamRequest(serverMessage.getWechatstreamrequest(), seq);
                    }
                    catch (e) {
                        this.error(new GrpcClient_1.IOError(e, `[tid:${this.traceId}] Exception while handling wechat stream request`));
                    }
                }
                else if (serverMessage.getPayloadCase() === padlocal_pb_1.ActionMessage.PayloadCase.SYSTEMEVENTREQUEST) {
                    this.subReply(seq, new padlocal_pb_1.SystemEventResponse());
                    (_a = this.onSystemEventCallback) === null || _a === void 0 ? void 0 : _a.call(this, serverMessage.getSystemeventrequest());
                }
                else {
                    (_b = this.onMessageCallback) === null || _b === void 0 ? void 0 : _b.call(this, serverMessage);
                }
            }
        });
    }
    _handleStreamRequest(wechatStreamRequest, ack) {
        return __awaiter(this, void 0, void 0, function* () {
            if (wechatStreamRequest.getPayloadCase() == padlocal_pb_1.WeChatStreamRequest.PayloadCase.SOCKETREQUEST) {
                const socketStreamHandler = new SocketStreamHandler_1.SocketStreamHandler(this);
                yield socketStreamHandler.handleRequest(wechatStreamRequest, ack);
            }
            else if (wechatStreamRequest.getPayloadCase() == padlocal_pb_1.WeChatStreamRequest.PayloadCase.LONGLINKREQUEST) {
                const longLinkRequest = wechatStreamRequest.getLonglinkrequest();
                let longLinkProxy;
                if (longLinkRequest.getInitphase()) {
                    longLinkProxy = this.client.getLongLinkProxyDirect();
                }
                else {
                    longLinkProxy = yield this.client.getLongLinkProxy();
                }
                const longLinkStreamHandler = new LongLinkStreamHandler_1.LongLinkStreamHandler(this, longLinkProxy);
                yield longLinkStreamHandler.handleRequest(wechatStreamRequest, ack);
            }
            else if (wechatStreamRequest.getPayloadCase() == padlocal_pb_1.WeChatStreamRequest.PayloadCase.PUSHSUBSCRIBEREQUEST) {
                const longLinkProxy = yield this.client.getLongLinkProxy();
                const pushStreamHandler = new PushStreamHandler_1.PushStreamHandler(this, longLinkProxy);
                yield pushStreamHandler.handleRequest(wechatStreamRequest, ack);
            }
            else if (wechatStreamRequest.getPayloadCase() == padlocal_pb_1.WeChatStreamRequest.PayloadCase.FILEUPLOADREQUEST) {
                const fileUploadStreamHandler = new FileUploadStreamHandler_1.FileUploadStreamHandler(this, this.extraData.fileUploadStreamHandlerParams);
                yield fileUploadStreamHandler.handleRequest(wechatStreamRequest, ack);
            }
            else {
                throw new Error(`unsupported wechat request case: ${wechatStreamRequest.getPayloadCase()}`);
            }
        });
    }
    _handleNormalRequest(wechatRequest, ack) {
        return __awaiter(this, void 0, void 0, function* () {
            if (wechatRequest.getPayloadCase() === padlocal_pb_1.WeChatRequest.PayloadCase.LONGLINKREQUEST) {
                const longLinkRequest = wechatRequest.getLonglinkrequest();
                let longLinkProxy;
                if (longLinkRequest.getInitphase()) {
                    longLinkProxy = this.client.getLongLinkProxyDirect();
                }
                else {
                    longLinkProxy = yield this.client.getLongLinkProxy();
                }
                yield longLinkProxy.sendRequest(longLinkRequest);
                this.subReply(ack, new padlocal_pb_1.WeChatResponse().setLonglinkresponse(new padlocal_pb_1.WeChatLongLinkResponse()));
            }
            else if (wechatRequest.getPayloadCase() === padlocal_pb_1.WeChatRequest.PayloadCase.SHORTLINKREQUEST) {
                const shortLinkRequest = wechatRequest.getShortlinkrequest();
                const shortLinkProxy = new WeChatShortLinkProxy_1.WeChatShortLinkProxy(shortLinkRequest.getHost().getHost(), shortLinkRequest.getHost().getPort(), this.traceId);
                const responseData = yield shortLinkProxy.send(shortLinkRequest.getPath(), Buffer.from(shortLinkRequest.getPayload()));
                const weChatResponse = new padlocal_pb_1.WeChatResponse().setShortlinkresponse(new padlocal_pb_1.WeChatShortLinkResponse().setPayload(responseData));
                this.subReply(ack, weChatResponse);
            }
            else if (wechatRequest.getPayloadCase() === padlocal_pb_1.WeChatRequest.PayloadCase.HTTPREQUEST) {
                const httpRequest = wechatRequest.getHttprequest();
                const httpProxy = new WeChatHttpProxy_1.WeChatHttpProxy(this.traceId, httpRequest);
                const httpResponse = yield httpProxy.send();
                const wechatResponse = new padlocal_pb_1.WeChatResponse().setHttpresponse(httpResponse);
                this.subReply(ack, wechatResponse);
            }
            else {
                throw new Error(`unsupported wechat request case: ${wechatRequest.getPayloadCase()}`);
            }
        });
    }
    _completePendingRequest(ack, payload, seq) {
        const p = this._pendingCallbacks.get(ack);
        this._pendingCallbacks.delete(ack);
        if (!p) {
            return;
        }
        p.resolve({
            ack: seq,
            payload,
        });
    }
    _failPendingRequest(ack, error) {
        const p = this._pendingCallbacks.get(ack);
        this._pendingCallbacks.delete(ack);
        p === null || p === void 0 ? void 0 : p.reject(error);
    }
    _failAllPendingRequest(status, error) {
        if (status === Status.SERVER_ERROR || status === Status.CLIENT_ERROR) {
            Log_1.default.error(LOGPRE, `[tid:${this.traceId}], padlocal grpc request failed: ${status}, error: ${error}`);
        }
        const e = new SubRequestCancelError(this.traceId, status, error);
        for (const [, p] of this._pendingCallbacks.entries()) {
            p.reject(e);
        }
        this._pendingCallbacks.clear();
    }
    error(e) {
        if (this._status !== Status.OK) {
            return;
        }
        this._failAllPendingRequest(Status.CLIENT_ERROR, e);
        // set before requestObserver.onError, because requestObserver.onError will cause onError callback
        this._status = Status.CLIENT_ERROR;
        // whatever exception called in client.onError, server will receive "cancelled before receiving half close" error.
        this._grpcStream.cancel();
    }
    complete() {
        if (this._status !== Status.OK) {
            return;
        }
        this._failAllPendingRequest(Status.CLIENT_COMPLETE, new Error("Grpc client complete"));
        // set before requestObserver.onCompleted, because requestObserver.onCompleted will cause onCompleted callback
        this._status = Status.CLIENT_COMPLETE;
        this._grpcStream.end();
    }
}
exports.Request = Request;
var Status;
(function (Status) {
    Status[Status["OK"] = 0] = "OK";
    Status[Status["SERVER_ERROR"] = 1] = "SERVER_ERROR";
    Status[Status["SERVER_COMPLETE"] = 2] = "SERVER_COMPLETE";
    Status[Status["CLIENT_ERROR"] = 3] = "CLIENT_ERROR";
    Status[Status["CLIENT_COMPLETE"] = 4] = "CLIENT_COMPLETE";
})(Status = exports.Status || (exports.Status = {}));
class SubRequestCancelError extends verror_1.default {
    constructor(traceId, reason, cause, message) {
        if (cause) {
            super(cause, `[tid:${traceId}] request has been cancelled for reason: ${Status[reason]}${message ? ", " + message : ""}`);
        }
        else {
            super(`[tid:${traceId}] request has been cancelled for reason: ${Status[reason]}${message ? ", " + message : ""}`);
        }
        this.reason = reason;
    }
}
exports.SubRequestCancelError = SubRequestCancelError;
//# sourceMappingURL=Request.js.map