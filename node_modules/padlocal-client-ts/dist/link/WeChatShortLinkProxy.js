"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeChatShortLinkProxy = void 0;
const RetryStrategy_1 = require("../utils/RetryStrategy");
const ByteUtils_1 = require("../utils/ByteUtils");
const http_1 = __importDefault(require("http"));
const erros_1 = require("./erros");
const Log_1 = __importDefault(require("../utils/Log"));
const LOGPRE = "[ShortLink]";
class WeChatShortLinkProxy {
    constructor(host, port, traceId, timeout) {
        this.retryStrategy = RetryStrategy_1.RetryStrategy.getStrategy(RetryStrategy_1.RetryStrategyRule.FAST, 5); // retry almost 1 min
        this.host = host;
        this.port = port;
        this.traceId = traceId;
        this.reqTimeout = timeout || WeChatShortLinkProxy.REQ_TIMEOUT;
    }
    send(path, data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._sendImpl(path, data);
            }
            catch (e) {
                if (!(e instanceof erros_1.IOError)) {
                    throw e;
                }
                if (!this.retryStrategy.canRetry()) {
                    const message = `[tid:${this.traceId}] Fail to request short link, url: http://${this.host}:${this.port}${path}, data: ${ByteUtils_1.bytesToHexString(data, ByteUtils_1.MAX_LOG_BYTES_LEN)}, after max retry:${this.retryStrategy.retryCount}`;
                    Log_1.default.error(LOGPRE, message);
                    throw new erros_1.IOError(e, message);
                }
                const delay = this.retryStrategy.nextRetryDelay();
                Log_1.default.warn(LOGPRE, `[tid:${this.traceId}] short link #${this.retryStrategy.retryCount} retry request, after delay: ${delay}ms, url: http://${this.host}:${this.port}${path}, data: ${ByteUtils_1.bytesToHexString(data, ByteUtils_1.MAX_LOG_BYTES_LEN)}`);
                return new Promise((resolve, reject) => {
                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        try {
                            const response = yield this.send(path, data);
                            resolve(response);
                        }
                        catch (e) {
                            reject(e);
                        }
                    }), delay);
                });
            }
        });
    }
    _sendImpl(path, data) {
        return __awaiter(this, void 0, void 0, function* () {
            Log_1.default.silly(LOGPRE, `[tid:${this.traceId}] short link send, ${this.host}:${this.port}${path}, request: ${ByteUtils_1.bytesToHexString(data, ByteUtils_1.MAX_LOG_BYTES_LEN)}`);
            return new Promise((resolve, reject) => {
                let responseBuffer = ByteUtils_1.newBytes();
                const req = http_1.default.request(`http://${this.host}:${this.port}${path}`, {
                    method: "POST",
                    headers: {
                        Accept: "*/*",
                        "Cache-Control": "no-cache",
                        Connection: "close",
                        "Content-Length": data.length,
                        "Content-Type": "application/octet-stream",
                        Upgrade: "mmtls",
                        "User-Agent": "MicroMessenger Client",
                    },
                    timeout: this.reqTimeout,
                }, (res) => {
                    if (res.statusCode && res.statusCode >= 400) {
                        reject(new erros_1.HttpError(`http status error, status: ${res.statusCode}, message:${res.statusMessage}`));
                    }
                    res.on("data", (chunk) => {
                        responseBuffer = ByteUtils_1.joinBytes(responseBuffer, chunk);
                    });
                    res.on("end", () => {
                        Log_1.default.silly(LOGPRE, `[tid:${this.traceId}] short link receive, response: ${ByteUtils_1.bytesToHexString(responseBuffer, ByteUtils_1.MAX_LOG_BYTES_LEN)}`);
                        resolve(responseBuffer);
                    });
                });
                req.on("timeout", () => {
                    req.destroy(new erros_1.IOError("timeout"));
                });
                req.on("error", (e) => {
                    const errorCode = e.code;
                    // dns resolve failed
                    if (errorCode === "ENOTFOUND") {
                        e = new erros_1.IOError(e, "ENOTFOUND");
                    }
                    else if (errorCode === "ETIMEDOUT") {
                        e = new erros_1.IOError(e, "ETIMEDOUT");
                    }
                    reject(e);
                });
                req.write(data);
                req.end();
            });
        });
    }
}
exports.WeChatShortLinkProxy = WeChatShortLinkProxy;
WeChatShortLinkProxy.REQ_TIMEOUT = 10 * 1000;
//# sourceMappingURL=WeChatShortLinkProxy.js.map