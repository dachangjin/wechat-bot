import * as pb from "./proto/padlocal_pb";
import { Bytes } from "./utils/ByteUtils";
import { PadLocalClientPlugin } from "./PadLocalClientPlugin";
import { PadLocalClient } from "./PadLocalClient";
export declare class PadLocalClientApi extends PadLocalClientPlugin {
    private static readonly FILE_UPLOAD_REQUEST_TIMEOUT;
    private _revokeMessageSeq;
    constructor(client: PadLocalClient);
    login(loginPolicy: pb.LoginPolicy, callback: LoginCallback): Promise<void>;
    logout(): Promise<pb.LogoutResponse>;
    sync(scene: pb.SyncRequestScene): Promise<pb.SyncEvent>;
    /**
     * @param toUserName
     * @param text
     * @param atList
     * @param idempotentId: id used to forbidden idempotent problem caused by retry.
     * @return
     */
    sendTextMessage(idempotentId: string, toUserName: string, text: string, atList?: string[]): Promise<pb.SendTextMessageResponse>;
    /**
     * @param toUserName
     * @param image
     * @param idempotentId: id used to forbidden idempotent problem caused by retry.
     * @return
     */
    sendImageMessage(idempotentId: string, toUserName: string, image: Bytes): Promise<pb.SendImageMessageResponse>;
    /**
     *
     * @param idempotentId
     * @param toUserName
     * @param voice
     * @param voiceLength: voice length show to receiver, in milliseconds
     */
    sendVoiceMessage(idempotentId: string, toUserName: string, voice: Bytes, voiceLength: number): Promise<pb.SendVoiceMessageResponse>;
    sendVideoMessage(idempotentId: string, toUserName: string, video: Bytes): Promise<pb.SendVideoMessageResponse>;
    sendFileMessage(idempotentId: string, toUserName: string, file: Bytes, fileName: string): Promise<pb.SendFileMessageResponse>;
    /**
     * @param idempotentId: id used to forbidden idempotent problem caused by retry.
     * @param toUserName
     * @param link
     * @return
     */
    sendMessageLink(idempotentId: string, toUserName: string, link: pb.AppMessageLink): Promise<pb.SendAppMessageResponse>;
    sendMessageMiniProgram(idempotentId: string, toUserName: string, miniProgram: pb.AppMessageMiniProgram, thumbImage: Bytes | null): Promise<pb.SendAppMessageResponse>;
    sendContactCardMessage(idempotentId: string, toUserName: string, contact: pb.Contact): Promise<pb.SendContactCardMessageResponse>;
    sendMessageEmoji(idempotentId: string, toUserName: string, md5: string, len: number, type?: number, gameExt?: string): Promise<pb.SendEmojiMessageResponse>;
    forwardMessage(idempotentId: string, toUserName: string, messageContent: string, messageType: number, messageToUserName: string): Promise<pb.ForwardMessageResponse>;
    getMessageImage(messageContent: string, messageToUserName: string, imageType: pb.ImageType): Promise<GetMessageImageResult>;
    getMessageVoice(messageId: string, messageContent: string, messageToUserName: string): Promise<Bytes>;
    getMessageVideoThumb(messageContent: string, messageToUserName: string): Promise<Bytes>;
    getMessageVideo(messageContent: string, messageToUserName: string): Promise<Bytes>;
    getMessageAttach(messageContent: string, messageToUserName: string): Promise<Bytes>;
    getMessageAttachThumb(messageContent: string, messageToUserName: string): Promise<Bytes>;
    getMessageMiniProgramThumb(messageContent: string, messageToUserName: string): Promise<Bytes>;
    getEncryptedFile(fileType: pb.EncryptedFileType, fileId: string, fileKey: Bytes, isChatRoomMessage?: boolean): Promise<Bytes>;
    revokeMessage(msgId: string, fromUserName: string, toUserName: string, messageRevokeInfo: pb.MessageRevokeInfo): Promise<void>;
    /**
     * sync contact is very costly, may be last for minutes, so use wisely.
     * @param callback
     */
    syncContact(callback: SyncContactCallback): Promise<void>;
    acceptUser(userName: string, ticket: string, stranger: string, scene: number): Promise<void>;
    addContact(stranger: string, ticket: string, scene: pb.AddContactScene, hello: string, roomId?: string, contactId?: string): Promise<void>;
    deleteContact(userName: string): Promise<void>;
    getContact(userName: string, ticket?: string): Promise<pb.Contact>;
    getContactQRCode(userName: string, style: number): Promise<pb.GetContactQRCodeResponse>;
    searchContact(userName: string): Promise<pb.SearchContactResponse>;
    updateSelfNickName(nickName: string): Promise<void>;
    updateSelfSignature(signature: string): Promise<void>;
    zombieTest(userName: string): Promise<pb.ZombieStatue>;
    updateContactRemark(userName: string, remark: string): Promise<void>;
    /**
     *
     * @param userNameList
     * @param idempotentId: id used to forbidden idempotent problem caused by retry.
     * @return
     */
    createChatRoom(idempotentId: string, userNameList: string[]): Promise<pb.CreateChatRoomResponse>;
    getChatRoomMembers(roomId: string): Promise<pb.ChatRoomMember[]>;
    getChatRoomQrCode(roomId: string): Promise<pb.GetChatRoomQrCodeResponse>;
    getChatRoomMember(roomId: string, userName: string): Promise<pb.Contact>;
    getChatRoomAnnouncement(roomId: string): Promise<string>;
    setChatRoomAnnouncement(roomId: string, announcement: string): Promise<void>;
    addChatRoomMember(roomId: string, userName: string): Promise<pb.AddChatRoomMemberType>;
    deleteChatRoomMember(roomId: string, userName: string): Promise<void>;
    setChatRoomName(roomId: string, name: string): Promise<void>;
    quitChatRoom(roomId: string): Promise<void>;
    acceptChatRoomInvitation(inviterUserName: string, invitationURL: string): Promise<void>;
    getLabelList(): Promise<pb.Label[]>;
    addLabel(label: string): Promise<number>;
    removeLabel(labelId: number): Promise<void>;
    setContactLabel(userName: string, labelIdList: number[]): Promise<void>;
    /**
     * @param maxId: 0 for the first page
     * @return
     */
    snsGetTimeline(maxId?: string): Promise<pb.SnsMoment[]>;
    snsGetUserPage(userName: string, maxId?: string): Promise<pb.SnsMoment[]>;
    snsGetMoment(momentId: string): Promise<pb.SnsMoment>;
    /**
     *
     * @param idempotentId: id used to forbidden idempotent problem caused by retry.
     * @param payload
     * @param options
     * @return
     */
    snsSendMoment(idempotentId: string, payload: pb.SnsSendMomentText | pb.SnsSendMomentImages | pb.SnsSendMomentUrl, options?: pb.SnsSendMomentOptions): Promise<pb.SnsMoment>;
    snsForwardMoment(idempotentId: string, momentContentXml: string, options?: pb.SnsSendMomentOptions): Promise<pb.SnsMoment>;
    /**
     *
     * @param momentId
     * @param idempotentId: id used to forbidden idempotent problem caused by retry.
     * @param momentOwnerUserName
     * @param commentText
     * @param replyTo
     * @return
     */
    snsSendComment(idempotentId: string, momentId: string, momentOwnerUserName: string, commentText: string, replyTo?: pb.SnsSendCommentReplyTo): Promise<pb.SnsMoment>;
    snsUploadImage(image: Bytes, description?: string): Promise<pb.SnsUploadImageResponse>;
    snsLikeMoment(momentId: string, momentOwnerUserName: string): Promise<pb.SnsMoment>;
    snsUnlikeMoment(momentId: string): Promise<void>;
    snsRemoveMomentComment(momentId: string, commentId: string): Promise<void>;
    snsMakeMomentPrivate(momentId: string): Promise<void>;
    snsMakeMomentPublic(momentId: string): Promise<void>;
    snsRemoveMoment(momentId: string): Promise<void>;
    sendClientStopSignal(): Promise<void>;
}
export interface LoginCallback {
    onLoginStart(loginType: pb.LoginType): void;
    onOneClickEvent(oneClickEvent: pb.QRCodeEvent): void;
    onQrCodeEvent(qrCodeEvent: pb.QRCodeEvent): void;
    onLoginSuccess(contact: pb.Contact): void;
    onSync(syncEvent: pb.SyncEvent): void;
}
export interface SyncContactCallback {
    onSync(contactList: pb.Contact[]): void;
}
export interface GetMessageImageResult {
    readonly imageType: pb.ImageType;
    readonly imageData: Bytes;
}
