import { PadLocalClient } from "./PadLocalClient";
import { ActionMessage, SystemEventRequest } from "./proto/padlocal_pb";
import { Message } from "google-protobuf";
import VError from "verror";
import { GrpcOptions } from "./GrpcClient";
import { PadLocalClientPlugin } from "./PadLocalClientPlugin";
import { FileUploadStreamHandlerParams } from "./link/FileUploadStreamHandler";
export declare type OnMessageCallback = (actionMessage: ActionMessage) => void;
export declare type OnSystemEventCallback = (systemEventRequest: SystemEventRequest) => void;
export declare type RequestExtraData = {
    fileUploadStreamHandlerParams?: FileUploadStreamHandlerParams;
};
export declare class Request extends PadLocalClientPlugin {
    private _status;
    private _seqId;
    private _grpcStream?;
    private _pendingCallbacks;
    private readonly _requestTimeout;
    readonly traceId: string;
    onMessageCallback?: OnMessageCallback;
    onSystemEventCallback?: OnSystemEventCallback;
    extraData?: RequestExtraData;
    constructor(client: PadLocalClient, options?: Partial<GrpcOptions>);
    request<REQ extends Message, RES extends Message>(request: REQ): Promise<RES>;
    /**
     * @param request: request payload
     * @param sendOnly: if true, do not wait for server's ask, return null immediately
     * @return response
     */
    subRequest<REQ extends Message, RES extends Message>(request: REQ, sendOnly: boolean): Promise<SubResponse<RES> | void>;
    subReply<T extends Message>(ack: number, replay: T): void;
    /**
     * reply to ack, and send request need peer ack too
     * @param ack
     * @param request
     */
    subReplyAndRequest<REQ extends Message, RES extends Message>(ack: number, request: REQ): Promise<SubResponse<RES>>;
    private _sendMessage;
    /**
     * @param payload: message payload
     * @param seq: payload action and require ack reply
     * @param ack: reply action and reply #seq payload with ack
     *
     * Example:
     *  ┌───────┬───────┬───────────────────────────────────────────────┐
     *  │  seq  │  ack  │                  description                  │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │ null  │ null  │send only action, no ack required              │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │ null  │notnull│reply action, reply to payload that seq == ack │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │notnull│ null  │payload action, need ack                       │
     *  ├───────┼───────┼───────────────────────────────────────────────┤
     *  │notnull│notnull│reply action, and also need peer to reply      │
     *  └───────┴───────┴───────────────────────────────────────────────┘
     */
    private __sendMessage;
    private _onServerMessage;
    private _handleStreamRequest;
    private _handleNormalRequest;
    private _completePendingRequest;
    private _failPendingRequest;
    private _failAllPendingRequest;
    error(e: Error): void;
    complete(): void;
}
export declare enum Status {
    OK = 0,
    SERVER_ERROR = 1,
    SERVER_COMPLETE = 2,
    CLIENT_ERROR = 3,
    CLIENT_COMPLETE = 4
}
export declare class SubRequestCancelError extends VError {
    reason: Status;
    constructor(traceId: string, reason: Status, cause?: Error, message?: string);
}
export interface SubResponse<T extends Message> {
    payload: T;
    ack?: number;
}
