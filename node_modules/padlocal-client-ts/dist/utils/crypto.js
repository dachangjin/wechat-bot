"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.adler32 = exports.md5 = exports.AesEcbDecrypt = exports.AesEcbEncrypt = exports.AesGenKey = void 0;
const ByteUtils_1 = require("./ByteUtils");
const crypto_1 = __importDefault(require("crypto"));
const adler_32_1 = require("adler-32");
function AesGenKey(size) {
    return crypto_1.default.randomBytes(size || 16);
}
exports.AesGenKey = AesGenKey;
function AesEcbEncrypt(key, plainData) {
    const cipher = crypto_1.default.createCipheriv("aes-128-ecb", key, "");
    cipher.setAutoPadding(true);
    return ByteUtils_1.joinBytes(cipher.update(plainData), cipher.final());
}
exports.AesEcbEncrypt = AesEcbEncrypt;
function AesEcbDecrypt(key, encryptedData) {
    const cipher = crypto_1.default.createDecipheriv("aes-128-ecb", key, "");
    cipher.setAutoPadding(true);
    return ByteUtils_1.joinBytes(cipher.update(encryptedData), cipher.final());
}
exports.AesEcbDecrypt = AesEcbDecrypt;
function md5(data) {
    return crypto_1.default.createHash("md5").update(data).digest("hex");
}
exports.md5 = md5;
function adler32(data, seed) {
    return adler_32_1.buf(data, seed) >>> 0;
}
exports.adler32 = adler32;
//# sourceMappingURL=crypto.js.map