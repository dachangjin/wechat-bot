"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BytesReader = exports.subBytes = exports.joinBytes = exports.fromBytes = exports.newBytes = exports.hexStringToBytes = exports.bytesToHexString = exports.MAX_LOG_BYTES_LEN = void 0;
exports.MAX_LOG_BYTES_LEN = 2048;
function bytesToHexString(bytes, maxLen) {
    let truncatedLen = 0;
    if (maxLen !== undefined && bytes.length > maxLen) {
        truncatedLen = bytes.length - maxLen;
        bytes = subBytes(bytes, 0, maxLen);
    }
    let ret = Buffer.from(bytes).toString("hex");
    if (truncatedLen) {
        ret += `[TRUNCATED:${truncatedLen}]`;
    }
    return ret;
}
exports.bytesToHexString = bytesToHexString;
function hexStringToBytes(hexString) {
    return Buffer.from(Buffer.from(hexString, "hex"));
}
exports.hexStringToBytes = hexStringToBytes;
function newBytes(length) {
    return Buffer.alloc(length || 0);
}
exports.newBytes = newBytes;
function fromBytes(bytes) {
    return Buffer.from(bytes);
}
exports.fromBytes = fromBytes;
function joinBytes(...datas) {
    const totalLen = datas.reduce((sum, data) => sum + data.length, 0);
    const ret = Buffer.alloc(totalLen);
    let offset = 0;
    for (const data of datas) {
        ret.set(data, offset);
        offset += data.length;
    }
    return ret;
}
exports.joinBytes = joinBytes;
function subBytes(data, start, end) {
    return data.slice(start, end);
}
exports.subBytes = subBytes;
class BytesReader {
    constructor(buffer, bigEndian) {
        this._buffer = buffer;
        this._bigEndian = bigEndian;
        this._cursor = 0;
    }
    get cursor() {
        return this._cursor;
    }
    available() {
        return this._buffer.length - this._cursor;
    }
    readBoolean() {
        const ret = !!this._buffer.readUInt8(this._cursor);
        ++this._cursor;
        return ret;
    }
    readByte() {
        const ret = this._buffer.readInt8(this._cursor);
        ++this._cursor;
        return ret;
    }
    readUByte() {
        const ret = this._buffer.readUInt8(this._cursor);
        ++this._cursor;
        return ret;
    }
    readShort() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readInt16BE(this._cursor);
        }
        else {
            ret = this._buffer.readInt16LE(this._cursor);
        }
        this._cursor += 2;
        return ret;
    }
    readUShort() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readUInt16BE(this._cursor);
        }
        else {
            ret = this._buffer.readUInt16LE(this._cursor);
        }
        this._cursor += 2;
        return ret;
    }
    readInt() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readInt32BE(this._cursor);
        }
        else {
            ret = this._buffer.readInt32LE(this._cursor);
        }
        this._cursor += 4;
        return ret;
    }
    readUInt() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readUInt32BE(this._cursor);
        }
        else {
            ret = this._buffer.readUInt32LE(this._cursor);
        }
        this._cursor += 4;
        return ret;
    }
    readLong() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readBigInt64BE(this._cursor);
        }
        else {
            ret = this._buffer.readBigInt64LE(this._cursor);
        }
        this._cursor += 8;
        return ret;
    }
    readULong() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readBigUInt64BE(this._cursor);
        }
        else {
            ret = this._buffer.readBigUInt64LE(this._cursor);
        }
        this._cursor += 8;
        return ret;
    }
    readFloat() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readFloatBE(this._cursor);
        }
        else {
            ret = this._buffer.readFloatLE(this._cursor);
        }
        this._cursor += 4;
        return ret;
    }
    readDouble() {
        let ret;
        if (this._bigEndian) {
            ret = this._buffer.readDoubleBE(this._cursor);
        }
        else {
            ret = this._buffer.readDoubleLE(this._cursor);
        }
        this._cursor += 8;
        return ret;
    }
    readBytes(length) {
        const end = Math.min(this._buffer.length, this._cursor + length);
        const ret = subBytes(this._buffer, this._cursor, end);
        this._cursor = end;
        return ret;
    }
    reset() {
        this._cursor = 0;
    }
    skip(length) {
        this._cursor += Math.max(length, 0);
    }
}
exports.BytesReader = BytesReader;
//# sourceMappingURL=ByteUtils.js.map