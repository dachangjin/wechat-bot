"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareFileUpload = exports.prepareVideoUpload = exports.prepareImageUpload = exports.downloadFile = void 0;
const ByteUtils_1 = require("./ByteUtils");
const padlocal_pb_1 = require("../proto/padlocal_pb");
const FileUnpacker_1 = require("./FileUnpacker");
const SocketClient_1 = require("../link/SocketClient");
const Utils_1 = require("./Utils");
const crypto_1 = require("./crypto");
const crypto_2 = require("./crypto");
const MediaUtils_1 = require("./MediaUtils");
const Log_1 = __importDefault(require("./Log"));
const LOGPRE = "[FileUtils]";
function downloadFile(fileDownloadRequest, traceId) {
    return __awaiter(this, void 0, void 0, function* () {
        const host = fileDownloadRequest.getHost();
        const fileUnpacker = new FileUnpacker_1.FileUnpacker(ByteUtils_1.fromBytes(fileDownloadRequest.getUnpackaeskey()));
        const socketStartDate = new Date();
        Log_1.default.silly(LOGPRE, `[tid:${traceId}] send file request, host:\"${fileDownloadRequest
            .getHost()
            .getHost()}:${fileDownloadRequest.getHost().getPort()}\" payload: ${ByteUtils_1.bytesToHexString(ByteUtils_1.fromBytes(fileDownloadRequest.getPayload()), ByteUtils_1.MAX_LOG_BYTES_LEN)}`);
        let response = null;
        const socketClient = new SocketClient_1.SocketClient(host.getHost(), host.getPort(), traceId, {
            onConnect: () => __awaiter(this, void 0, void 0, function* () {
                fileUnpacker.reset();
            }),
            onReceive: (data) => __awaiter(this, void 0, void 0, function* () {
                const responseList = fileUnpacker.update(data);
                if (responseList.length) {
                    response = responseList[0];
                    return true;
                }
                else {
                    return false;
                }
            }),
        });
        yield socketClient.send(Buffer.from(fileDownloadRequest.getPayload()));
        const socketEndDate = new Date();
        const downloadCostTime = socketEndDate.getTime() - socketStartDate.getTime();
        if (!response) {
            throw new Error(`[tid:${traceId}] [${downloadCostTime}ms] download file failed:${Utils_1.stringifyPB(fileDownloadRequest)}, received null response`);
        }
        const retCode = FileUnpacker_1.FileResponse.unpackInteger(response.body["retcode"]);
        if (retCode !== 0) {
            throw new Error(`[tid:${traceId}] [${downloadCostTime}ms] download file failed:${Utils_1.stringifyPB(fileDownloadRequest)}, retcode: ${retCode}`);
        }
        const fileData = response.body["filedata"];
        Log_1.default.silly(LOGPRE, `[tid:${traceId}] [${downloadCostTime}ms] received response: ${retCode}, encrypted file len: ${fileData ? fileData.length : "null"}`);
        const ret = fileUnpacker.getDecryptedFileData(response);
        const decryptCostTime = new Date().getTime() - socketEndDate.getTime();
        Log_1.default.silly(LOGPRE, `[tid:${traceId}] [${decryptCostTime}ms] decrypted file data len: ${ret.length}`);
        return ret;
    });
}
exports.downloadFile = downloadFile;
function encryptUploadData(plainData, aesKey) {
    aesKey = aesKey || crypto_1.AesGenKey();
    const encryptedData = crypto_1.AesEcbEncrypt(aesKey, plainData);
    return {
        plainDataMeta: new padlocal_pb_1.FileUploadDataMeta()
            .setSize(plainData.length)
            .setChecksum(crypto_2.adler32(plainData, 0))
            .setMd5(crypto_2.md5(plainData)),
        encryptedDataMeta: new padlocal_pb_1.FileUploadEncryptedDataMeta()
            .setAeskey(aesKey)
            .setSize(encryptedData.length)
            .setChecksum(crypto_2.adler32(encryptedData, 0))
            .setMd5(crypto_2.md5(encryptedData)),
        encryptedData,
    };
}
function generateUploadImageMeta(imageData, aesKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const imageEncryptedRet = encryptUploadData(imageData, aesKey);
        const imageMeta = new padlocal_pb_1.FileUploadImageMeta();
        imageMeta.setPlaindatameta(imageEncryptedRet.plainDataMeta);
        imageMeta.setEncrypteddatameta(imageEncryptedRet.encryptedDataMeta);
        const imageSize = yield MediaUtils_1.getImageSize(imageData);
        imageMeta.setWidth(imageSize.width);
        imageMeta.setHeight(imageSize.height);
        return {
            imageMeta,
            encryptedImageData: imageEncryptedRet.encryptedData,
        };
    });
}
function generateUploadVideoMeta(videoData) {
    return __awaiter(this, void 0, void 0, function* () {
        const videoEncryptedRet = encryptUploadData(videoData);
        const videoMeta = new padlocal_pb_1.FileUploadVideoMeta();
        videoMeta.setPlaindatameta(videoEncryptedRet.plainDataMeta);
        videoMeta.setEncrypteddatameta(videoEncryptedRet.encryptedDataMeta);
        const videoDuration = yield MediaUtils_1.getVideoDurationSeconds(videoData);
        videoMeta.setDuration(videoDuration);
        return {
            videoMeta,
            encryptedVideoData: videoEncryptedRet.encryptedData,
        };
    });
}
function generateUploadFileMeta(fileData) {
    const fileEncryptedRet = encryptUploadData(fileData);
    fileEncryptedRet.encryptedDataMeta;
    return {
        plainDataMeta: fileEncryptedRet.plainDataMeta,
        encryptedDataMeta: fileEncryptedRet.encryptedDataMeta,
        encryptedData: fileEncryptedRet.encryptedData,
    };
}
function prepareImageUpload(imageData, useThumb = true) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const uploadImageMeta = yield generateUploadImageMeta(imageData);
        const aesKey = Buffer.from((_a = uploadImageMeta.imageMeta.getEncrypteddatameta()) === null || _a === void 0 ? void 0 : _a.getAeskey());
        const params = new padlocal_pb_1.FileUploadImageParams().setImagemeta(uploadImageMeta.imageMeta);
        const dataBag = {
            [(_b = uploadImageMeta.imageMeta.getEncrypteddatameta()) === null || _b === void 0 ? void 0 : _b.getMd5()]: uploadImageMeta.encryptedImageData,
        };
        if (useThumb) {
            const thumbImageData = yield MediaUtils_1.createImageThumb(imageData, 120);
            const uploadThumbImageMeta = yield generateUploadImageMeta(thumbImageData, aesKey);
            params.setThumbimagemeta(uploadThumbImageMeta.imageMeta);
            dataBag[(_c = uploadThumbImageMeta.imageMeta.getEncrypteddatameta()) === null || _c === void 0 ? void 0 : _c.getMd5()] = uploadThumbImageMeta.encryptedImageData;
        }
        return {
            params,
            aesKey,
            dataBag,
        };
    });
}
exports.prepareImageUpload = prepareImageUpload;
function prepareVideoUpload(videoData) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const uploadVideoMeta = yield generateUploadVideoMeta(videoData);
        const aesKey = Buffer.from((_a = uploadVideoMeta.videoMeta.getEncrypteddatameta()) === null || _a === void 0 ? void 0 : _a.getAeskey());
        const thumbImageData = yield MediaUtils_1.createVideoThumb(videoData, 360);
        const uploadThumbImageData = yield generateUploadImageMeta(thumbImageData, aesKey);
        return {
            params: new padlocal_pb_1.FileUploadVideoParams()
                .setVideometa(uploadVideoMeta.videoMeta)
                .setThumbimagemeta(uploadThumbImageData.imageMeta),
            aesKey,
            dataBag: {
                [(_b = uploadVideoMeta.videoMeta.getEncrypteddatameta()) === null || _b === void 0 ? void 0 : _b.getMd5()]: uploadVideoMeta.encryptedVideoData,
                [(_c = uploadThumbImageData.imageMeta.getEncrypteddatameta()) === null || _c === void 0 ? void 0 : _c.getMd5()]: uploadThumbImageData.encryptedImageData,
            },
        };
    });
}
exports.prepareVideoUpload = prepareVideoUpload;
function prepareFileUpload(fileData) {
    const uploadFileMeta = generateUploadFileMeta(fileData);
    const aesKey = Buffer.from(uploadFileMeta.encryptedDataMeta.getAeskey());
    return {
        params: new padlocal_pb_1.FileUploadFileParams()
            .setPlaindatameta(uploadFileMeta.plainDataMeta)
            .setEncrypteddatameta(uploadFileMeta.encryptedDataMeta),
        aesKey,
        dataBag: {
            [uploadFileMeta.encryptedDataMeta.getMd5()]: uploadFileMeta.encryptedData,
        },
    };
}
exports.prepareFileUpload = prepareFileUpload;
//# sourceMappingURL=FileUtils.js.map