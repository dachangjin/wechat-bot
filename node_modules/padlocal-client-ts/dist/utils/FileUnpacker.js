"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileResponse = exports.FileResponseHeader = exports.FileUnpacker = void 0;
const ByteUtils_1 = require("./ByteUtils");
const crypto_1 = require("./crypto");
class FileUnpacker {
    constructor(aesKey) {
        this._buffer = ByteUtils_1.newBytes();
        this._aesKey = aesKey;
        this.reset();
    }
    /**
     * @param data:
     * @return true, finish unpack all data
     */
    update(data) {
        this._buffer = ByteUtils_1.joinBytes(this._buffer, data);
        const ret = [];
        while (true) {
            const response = this._unpackResponse();
            if (!response) {
                break;
            }
            ret.push(response);
        }
        return ret;
    }
    getDecryptedFileData(fileResponse) {
        const encryptedFileData = fileResponse.body["filedata"];
        return crypto_1.AesEcbDecrypt(this._aesKey, encryptedFileData);
    }
    reset() {
        this._buffer = ByteUtils_1.newBytes();
    }
    _unpackResponse() {
        if (this._buffer.length < FileUnpacker.HEADER_MIN_LEN) {
            return null;
        }
        const header = this._unpackHeader();
        const responseLen = header.headerLen + header.bodyLen;
        if (this._buffer.length < responseLen) {
            return null;
        }
        const bodyData = ByteUtils_1.subBytes(this._buffer, header.headerLen, responseLen);
        this._buffer = ByteUtils_1.subBytes(this._buffer, responseLen, this._buffer.length);
        const body = FileUnpacker._unpackResponseBody(bodyData);
        return new FileResponse(header, body);
    }
    _unpackHeader() {
        const reader = new ByteUtils_1.BytesReader(this._buffer, true);
        const protocolByte = reader.readUByte();
        if (protocolByte !== 0xab) {
            throw new Error("response is not file protocol");
        }
        const totalLen = reader.readUInt();
        reader.skip(16);
        const bodyLen = reader.readUInt();
        const headerLen = totalLen - bodyLen;
        return new FileResponseHeader(headerLen, bodyLen);
    }
    static _unpackResponseBody(buff) {
        const ret = {};
        const reader = new ByteUtils_1.BytesReader(buff, true);
        while (reader.available() > 4) {
            const fieldNameLen = reader.readUInt();
            const fieldName = reader.readBytes(fieldNameLen).toString();
            const fieldValueLen = reader.readUInt();
            let fieldValue;
            if (fieldValueLen > 0) {
                fieldValue = reader.readBytes(fieldValueLen);
            }
            ret[fieldName] = fieldValue;
        }
        return ret;
    }
}
exports.FileUnpacker = FileUnpacker;
FileUnpacker.HEADER_MIN_LEN = 25;
class FileResponseHeader {
    constructor(headerLen, bodyLen) {
        this.headerLen = headerLen;
        this.bodyLen = bodyLen;
    }
}
exports.FileResponseHeader = FileResponseHeader;
class FileResponse {
    constructor(header, body) {
        this.header = header;
        this.body = body;
    }
    static unpackInteger(data) {
        if (data) {
            return parseInt(data.toString(), 10);
        }
        else {
            return undefined;
        }
    }
    static unpackString(data) {
        if (data) {
            return data.toString();
        }
        else {
            return undefined;
        }
    }
}
exports.FileResponse = FileResponse;
//# sourceMappingURL=FileUnpacker.js.map